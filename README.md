# Тегеграм бот - Система голосования

## Общая информация

Этот проект реализует систему голосования для студенческого совета с использованием метода Шульце для ранжирования кандидатов. Система построена с использованием языка Go и взаимодействует с базой данных PostgreSQL для хранения информации о делегатах, кандидатах и голосах. В качестве внешнего интерфейса для пользователей используется Telegram-бот.

Основные компоненты проекта:
- **Telegram-бот** — взаимодействует с пользователями, отправляя и получая команды.
- **База данных** — используется для хранения информации о делегатах, кандидатах и результатах голосования.
- **Алгоритм Шульце** — используется для обработки голосов и определения победителя на выборах.

## Логика проекта

### 1. Регистрация делегатов
Регистрация пользователей начинается с команды `/start` в Telegram. Пользователю предлагается ввести свой студенческий email, и на этот адрес отправляется код подтверждения. После успешного ввода кода делегат считается зарегистрированным в системе.

1. Пользователь отправляет команду `/start`, чтобы инициировать процесс регистрации.
2. Бот предлагает ввести студенческий email.
3. После ввода email:
   - Проверяется, существует ли делегат с таким email в базе данных.
   - Если делегат существует, генерируется код подтверждения, который отправляется на email.
   - Пользователь вводит код подтверждения в боте.
4. Если код введен верно, делегат регистрируется в системе, и его Telegram ID связывается с его профилем.

### 2. Голосование
Голосование осуществляется методом ранжирования кандидатов на основе метода Шульце. Каждый делегат должен упорядочить всех кандидатов, начиная с наиболее предпочтительного. Для этого бот последовательно предлагает выбирать кандидатов через кнопки.

0. Команда `/start_voting` от администратора запускает возможность голосования.
1. Команда `/vote` запускает процесс голосования для делегатов.
2. Бот отправляет список кандидатов, и пользователь начинает выбирать кандидатов по порядку предпочтения.
3. Бот сохраняет выборы пользователя и строит ранжированный список.
4. Как только делегат выбрал всех кандидатов, его голос сохраняется в базе данных.
5. Команда `/stop_voting` от администратора останавливает голосование.

### 3. Вычисление результатов
После завершения голосования администратор может вычислить результаты с помощью команды `/results`. Бот использует метод Шульце для определения победителя и ранжирования кандидатов.

1. Команда `/results` от администратора запускает процесс вычисления результатов.
2. Бот получает все голоса из базы данных.
3. Бот использует метод Шульце для вычисления победителя и ранжирования кандидатов.
4. Результаты сохраняются в базе данных.

### 4. Вывод результатов
Администратор может просмотреть результаты. Бот выводит список кандидатов в порядке ранжирования, а также таблицы парных предпочтений и сильнейших путей.

1. Команда `/print` от администратора запускает процесс вывода результатов.
2. Команда `/csv` от администратора запускает процесс сохранения результатов в формате CSV.

## Дополнительные возможности

### 1. Управление кандидатами
Администратор может управлять списком кандидатов через специальные команды бота. Администратор может добавлять, удалять или блокировать кандидатов.

1. Команда `/add_candidate` — добавление нового кандидата.
2. Команда `/ban_candidate` — блокировка кандидата, чтобы исключить его из выборов.
3. Команда `/delete_candidate` — удаление кандидата из системы.
4. Команда `/show_candidates` — показывает текущий список кандидатов.

### 2. Управление делегатами
Администратор также может управлять делегатами через команды:
1. Команда `/add_delegate` — добавление нового делегата в систему.
2. Команда `/delete_delegate` — удаление делегата из системы.
3. Команда `/show_delegates` — показывает текущий список делегатов.

### 3. Логирование и мониторинг
Логирование используется для отслеживания состояния системы, ошибок и других событий. Логи пишутся в файл `bot.log`, а также могут отправляться администратору через Telegram.

1. Все ключевые действия, такие как регистрация, голосование, добавление/удаление делегатов и кандидатов, логируются для последующего анализа.
2. Ошибки также логируются и могут быть отправлены администратору через бота.
3. Команда `/log_level` — позволяет изменить уровень логирования.
4. Команда `/send_logs` — отправляет администратору логи системы.

### 4. База данных
Проект использует PostgreSQL для хранения данных о делегатах, кандидатах, голосах и результатах выборов. Основные таблицы:
- **delegates** — информация о делегатах.
- **candidates** — информация о кандидатах.
- **votes** — результаты голосования (ранжированные списки).
- **results** — результаты выборов (победители и ранжирование).

---

# Регистрация пользователя

Регистрация делегатов в системе осуществляется через бота в Telegram. Процесс регистрации включает в себя ввод почты, проверку её корректности и последующую верификацию через код подтверждения.

## 1. Начало регистрации

### Функция: `handleStart(ctx, message)`
1. Проверяет, зарегистрирован ли пользователь (по `Telegram ID`) в базе данных.
2. Если пользователь уже зарегистрирован, сообщает, что повторная регистрация невозможна.
3. Если пользователь не зарегистрирован, бот запрашивает его студенческую почту (в формате `stXXXXXX`) и переводит его состояние в режим ожидания ввода почты (`StateWaitingForEmail`).

---

## 2. Ввод почты

### Функция: `handleEmailInput(ctx, message)`
1. Проверяет формат введенной почты на соответствие шаблону `stXXXXXX`.
2. Извлекает ID делегата из почты и проверяет его существование в базе данных.
3. Если почта корректна и делегат найден, генерируется шестизначный код подтверждения.
4. Код отправляется на почту делегата, а состояние пользователя переводится в режим ожидания кода (`StateWaitingForCode`).

---

## 3. Ввод кода подтверждения

### Функция: `handleCodeInput(ctx, message)`
1. Проверяет, совпадает ли введенный пользователем код с ранее отправленным.
2. Если код верен, бот верифицирует пользователя, связывая его `Telegram ID` с профилем делегата.
3. Пользователь получает уведомление об успешной регистрации.

---

## Вспомогательные функции

- **`isValidEmail(email)`** — Проверяет формат почты на соответствие шаблону `stXXXXXX`.
- **`generateCode()`** — Генерирует случайный шестизначный код подтверждения.

---

# Голосование

Процесс голосования реализован через бот в Telegram, где делегаты ранжируют кандидатов по предпочтению, используя **метод Шульце**. Каждый делегат выбирает кандидатов по очереди с помощью кнопок в боте.

## 1. Начало голосования

### Функция: `handleVote(ctx, message)`
1. Проверяет, началось ли голосование (флаг `activeVoting`).
2. Если голосование активно, проверяет, зарегистрирован ли пользователь как делегат.
3. Отправляет пользователю инструкцию по методу Шульце и список кандидатов.
4. Создает пустой бюллетень для делегата, где будет храниться его ранжирование.
5. Показывает пользователю клавиатуру с кнопками для выбора кандидатов.

---

## 2. Выбор кандидатов

### Функция: `handleCallbackQuery(ctx, query)`
1. При выборе кандидата, бот проверяет, не был ли этот кандидат уже выбран ранее.
2. Добавляет выбранного кандидата в бюллетень делегата.
3. Обновляет клавиатуру с оставшимися кандидатами.
4. Если все кандидаты выбраны, бот проверяет уникальность голосов (проверка на порчу бюллетеня).
5. Сохраняет бюллетень в базу данных и уведомляет пользователя, что голос учтен.

---

## 3. Сохранение бюллетеня

### Функция: `sendRankedList(ctx, query)`
1. После того, как пользователь завершил выбор всех кандидатов, бот формирует итоговый бюллетень.
2. Отправляет пользователю подтверждение, что его голос учтен.
3. Сохраняет данные в базу, обновляя статус делегата как проголосовавшего.

---

## Вспомогательные функции

- **`sendCandidateKeyboard(ctx, message, editMsg)`** — Отправляет или обновляет клавиатуру с кандидатами для выбора.
- **`isUniqueCandidates(rankedList)`** — Проверяет, что все выбранные кандидаты уникальны (не допуская порчи бюллетеня).
- **`contains(slice, element)`** — Проверяет, был ли кандидат уже добавлен в бюллетень делегата.

---

## Логика процесса голосования:
1. Пользователь начинает голосование командой `/vote`.
2. Бот предоставляет кандидатов для выбора в виде кнопок.
3. Пользователь последовательно выбирает всех кандидатов.
4. Как только все кандидаты ранжированы, бот сохраняет бюллетень в базу и уведомляет делегата, что голос принят.

**Примечание:** Делегат может переголосовать, если это предусмотрено, повторно отправив команду `/vote` до завершения выборов.

---

# Функционал администратора

Администратор системы может выполнять следующие действия:
- Управление делегатами (добавление, удаление).
- Управление кандидатами (добавление, удаление, блокировка).
- Управление процессом голосования (запуск, остановка).
- Просмотр информации о делегатах, кандидатах и голосах.
- Просмотр результатов голосования.
- Логирование событий и ошибок.
## Логика процесса администрирования:
1. Администратор использует команды для управления делегатами, кандидатами и процессом голосования.
2. Бот проверяет корректность введенных данных, взаимодействует с базой данных и выполняет соответствующие действия.
3. Администратор получает уведомления об успешных операциях через бота.

---

# Пакеты `chain` и `db`

## Логика работы

### Пакет `chain`
Этот пакет реализует бизнес-логику приложения. Он принимает команды от бота и вызывает функции из пакета `db` для работы с базой данных. Также здесь происходит управление транзакциями: каждое действие, связанное с добавлением, обновлением или удалением данных, выполняется в контексте транзакции.

Основные функции:
- **Добавление/удаление кандидатов и делегатов** — через методы `AddCandidate`, `DeleteDelegate` и другие. Эти функции сначала проверяют данные (например, существует ли запись), затем вызывают соответствующие методы из `db` для выполнения операций.
- **Проверка существования данных** — функции `CheckExistDelegateByTelegramID` и аналогичные используются для проверки наличия делегатов или кандидатов в базе данных.
- **Голосование** — функция `AddVote` сохраняет голос делегата в базу, а также обновляет его статус как "проголосовавшего".

Пример транзакции в `chain`:
```go
func (vc *VoteChain) AddCandidate(ctx context.Context, candidate models.Candidate) error {
    tx, err := vc.storage.DB.BeginTx(ctx, pgx.TxOptions{IsoLevel: pgx.Serializable}) // Начинаем транзакцию
    if err != nil {
        return fmt.Errorf("chain.AddCandidate: can't start transaction: %w", err)
    }
    defer tx.Rollback(ctx) // Откат транзакции в случае ошибки

    // Логика добавления кандидата
    if err := vc.storage.AddCandidate(ctx, tx, candidate); err != nil {
        return fmt.Errorf("chain.AddCandidate: %w", err)
    }

    return tx.Commit(ctx) // Завершаем транзакцию, если всё прошло успешно
}
```

### Пакет `db`
Пакет `db` содержит функции для работы с базой данных PostgreSQL, включая операции CRUD (создание, чтение, обновление, удаление). Внутри этих методов используются SQL-запросы для взаимодействия с таблицами.

Основные функции:
- **Добавление, обновление, удаление** — функции `AddCandidate`, `UpdateDelegate`, `DeleteVote` и другие реализуют добавление, изменение и удаление записей в базе данных.
- **Получение данных** — функции `GetAllDelegates`, `GetVoteByDelegateID` и другие возвращают записи из базы данных.

Пример выполнения SQL-запроса в `db`:
```go
func (s *Storage) AddCandidate(ctx context.Context, tx pgx.Tx, candidate models.Candidate) error {
    _, err := tx.Exec(ctx,
        "INSERT INTO candidates (candidate_id, name, course, description, is_eligible) VALUES ($1, $2, $3, $4, $5)",
        candidate.CandidateID, candidate.Name, candidate.Course, candidate.Description, candidate.IsEligible)
    if err != nil {
        return fmt.Errorf("db.AddCandidate: insert failed: %w", err)
    }
    return nil
}
```

## Пример работы: Добавление кандидата

Когда администратор добавляет кандидата, выполняется следующая цепочка действий:
1. Бот получает команду `/add_candidate`.
2. В функции `handleAddCandidate` пакета `bot` вызывается метод `AddCandidate` из пакета `chain`.
3. В `chain.AddCandidate` начинается транзакция:
   - Проверяется, существует ли кандидат.
   - Если нет, вызывается метод `AddCandidate` из пакета `db`, который выполняет SQL-запрос на добавление записи в таблицу `candidates`.
   - Если всё прошло успешно, транзакция подтверждается.
4. Кандидат успешно добавлен в базу данных, администратор уведомляется о завершении операции.

---

# Метод Шульце

## Общая информация

**Метод Шульце** (Schulze Method) — это алгоритм, используемый для проведения выборов, где каждый участник голосует, ранжируя кандидатов от наиболее до наименее предпочтительного. Алгоритм используется для вычисления **пары предпочтений** между всеми кандидатами и на основе этого строит "победный путь", чтобы определить кандидата-победителя.

Этот метод особенно полезен, когда важно не только количество первых мест у кандидатов, но и их положение в общем рейтинге.

## Принцип работы

1. **Ранжирование кандидатов**: 
   - Каждый делегат упорядочивает всех кандидатов по предпочтению. Например: А > Б > В (А — на первом месте, Б — на втором, В — на третьем).
   
2. **Пары предпочтений**:
   - Для каждой пары кандидатов (например, А и Б) подсчитывается, сколько раз один кандидат предпочтительнее другого по мнению делегатов. Эти данные заносятся в матрицу предпочтений.

3. **Построение путей**:
   - Алгоритм строит сильнейший путь предпочтений между всеми парами кандидатов, создавая "граф путей". Сильнейший путь — это максимальный выбор минимимальной силы предпочтения пути для каждой пары.
   
4. **Определение победителя**:
   - Кандидат, для которого сильнейший путь предпочтений ко всем остальным кандидатам больше либо равен сильнейшего пути от остальных кандидатов к нему, считается победителем.

## Реализация в проекте

### Пакет: `schulze`

Этот пакет отвечает за реализацию метода Шульце и расчёт результатов на основе ранжирования, переданного делегатами. Основные функции включают:
- Создание матрицы предпочтений.
- Построение сильнейших путей между кандидатами.
- Вычисление победителя.

---

## Основные функции

### 1. `calculatePairwisePreferences(votes [][]int, numCandidates int) [][]int`
Эта функция создает **матрицу парных предпочтений**, используя ранжирование кандидатов, полученное от всех делегатов.

**Логика:**
- Для каждой пары кандидатов (A и B) подсчитывается количество голосов, где A предпочтительнее B, и наоборот.
- Результат записывается в матрицу предпочтений, где ячейка `[A][B]` хранит количество голосов, где A лучше B.

**Пример:**
- Если 3 делегата предпочитают кандидата A перед кандидатом B, в матрице предпочтений для пары (A, B) будет стоять число 3.

---

### 2. `calculateStrongestPaths(preferences [][]int, numCandidates int) [][]int`
Функция строит **сильнейшие пути предпочтений** между всеми кандидатами.

**Логика:**
- Используется алгоритм поиска путей, чтобы для каждой пары кандидатов A и B вычислить сильнейший путь предпочтений.
- Сильнейший путь для пары кандидатов — это максимальная сила минимального звена среди всевозожможных путей.

---

### 3. `getWinner(strongestPaths [][]int, numCandidates int) int`
Функция определяет победителя на основе сильнейших путей между кандидатами.

**Логика:**
- Кандидат A считается победителем, если для всех других кандидатов B сильнейший путь предпочтения от A к B больше либо равен от B к A.
- Возвращается ID победителя.

### 4. 'buildStrictOrder(candidates []models.Candidate, preferences [][]int, strongestPaths [][]int, numCandidates int) []models.Candidate'
Функция строит строгий порядок кандидатов на основе матрицы предпочтений и сильнейших путей.

**Логика:**
- Последовательно находим победителя, записываем его в порядок и находим победителя для оставшихся кандидатов.
- Возвращает кандидатов в строгом отношении порядка.

### 5. 'tieBreaker(tieCandidates []models.Candidate, candidates []models.Candidate, preferences [][]int, strongestPaths [][]int) []models.Candidate'
Функция разрешает ситуации, когда несколько кандидатов имеют одинаковую силу предпочтений.

**Логика:**
- Если несколько кандидатов имеют одинаковую силу предпочтений по отношению друг к другу, то, согласно Шульце, мы предпологаем, что они имеют общее звено, формирующее силу их путей.
- Мы находим это звено с помощью DFS и "удаляем" его.
- Пересчитываем силы их путей по отношению друг к другу (и только по отношению друг к другу). Повторяем в случае необходимости.
- Получаем победителя на основании пересчитанных сил путей.

---

## Пример работы метода

Допустим, у нас есть 3 кандидата (A, B, C) и следующие ранжированные голоса от делегатов:
1. A > B > C
2. B > A > C
3. A > C > B

### Шаг 1: Матрица предпочтений
После подсчета парных предпочтений получится следующая матрица:

|   | A  | B  | C  |
|---|----|----|----|
| A | -  | 2  | 3  |
| B | 1  | -  | 2  |
| C | 0  | 1  | -  |

Это значит, что:
- A предпочтительнее B для 2 делегатов, B предпочтительнее A для 1 делегата.
- A предпочтительнее C для 2 делегатов, C предпочтительнее A для 0 делегата.
- B предпочтительнее C для 2 делегатов, C предпочтительнее B для 1 делегата.

### Шаг 2: Построение сильнейших путей
Далее строится матрица/граф сильнейших путей на основе матрицы предпочтений:

|   | A  | B  | C  |
|---|----|----|----|
| A | -  | 2  | 3  |
| B | 0  | -  | 2  |
| C | 0  | 0  | -  |

В этом случае сильнейший путь от A к B равен 2. Сильнейший путь от A к C равен 3, а от B к C равен 2.
Все остальные пути равны 0, так как не существует путей между ними.

**Примечание:** По методу Шульце ребро А —> В при построении графа путей существует тогда и только тогда, когда предпочтение A->В больше предпочтения B->A.

### Шаг 3: Определение победителя
Кандидат A имеет сильнейший путь предпочтений по отношению к B и C, следовательно, A становится победителем выборов.
Далее в отношении строгого порядка идет кандидат B, который имеет сильнейший путь предпочтений по отношению к C.

---

## Пример использования в проекте

Функция подсчета результатов голосования может вызываться из бизнес-логики после завершения голосования. Например:

```go
// Подсчет результатов голосования
func (vc *VoteChain) CalculateResults(ctx context.Context) (int, error) {
    votes, err := vc.storage.GetAllVotes(ctx) // Получаем все голоса
    if err != nil {
        return 0, err
    }

    numCandidates := len(vc.Candidates) // Количество кандидатов
    preferences := schulze.CalculatePairwisePreferences(votes, numCandidates) // Шаг 1: Матрица предпочтений
    paths := schulze.CalculateStrongestPaths(preferences, numCandidates)      // Шаг 2: Сильнейшие пути
    winner := schulze.GetWinner(paths, numCandidates)                         // Шаг 3: Определение победителя

    return winner, nil
}
```
---

# Пошаговая инструкция для запуска проекта:

### 1. Скопируйте репозиторий на свой компьютер;
### 2. Установите все необходимые программы и утилиты;
- Docker;
- Docker-compose;
- Golang;
- makefile;
- goose;
### 3. Используйте `go mod tidy` для установки зависимостей;
### 4. С помощью .env.example создайте файл .env и внесите в него необходимые данные;
- TELEGRAM_APITOKEN - токен бота в телеграме (создаете получаете у [@BotFather](https://t.me/botfather))
- POSTGRES_USER - имя пользователя базы данных
- POSTGRES_PASSWORD - пароль от базы данных
- POSTGRES_DB - название базы данных
- NGROK_PORT - порт, на котором будет запущен контейнер bot (по умолчанию 8080)
- NGROK_URL - ссылка на ngrok (используется для переадресации обновлений от телеграма в контейнер bot)
- NGROK_AUTHTOKEN - токен для авторизации в ngrok (создаете и получаете на [сайте ngrok](https://dashboard.ngrok.com/))
- SMTP_EMAIL - почта для отправки уведомлений
- SMTP_PASSWORD - пароль от почты для отправки уведомлений (создаете и получааете пароль приложения у необходимого хоста почты)
- ADMIN_CHAT_ID - id чата администратора (id чатов и пользователей можно найти прямо в приложении телеграма)
- LOG_CHAT_ID - id чата для логирования
### 5. Пропишите необходимые sql миграции в `migrations/`;
- Рекомендуется использовать [goose](https://github.com/pressly/goose/) для работы с миграциями;
### 6. С помощью команды `make app2` запустите проект.
```make
app2: up-db app migrate ngrok-docker
    @echo -e "\033[32mAll containers started successfully\033[0m"

up-db:
	docker-compose up -d postgres
app:
	docker-compose up -d bot --build
migrate:
	goose -dir ./migrations postgres "postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:5432/${POSTGRES_DB}?sslmode=disable" up
ngrok-docker:
	docker-compose up -d ngrok
```

- Все необходимые контейнеры, миграции и пр. должны запуститься автоматически.

## Примечание
- Все команды используемые в makefile запускались в bash терминале VS Code на Windows 10. Возможно, на macOS, Linux или при использовании других терминалов они будут работать иначе или не работать вовсе - 
Гугл в помощь;
- Как найти, установить и запустить нужные программы и утилиты - Гугл в помощь;
- Как найти и прописать переменные окружения, токены, пароли и пр - Гугл в помощь;
- для некоторых тестов нужны моки, используйте команду `make mock`